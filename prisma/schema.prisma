generator client {
  provider = "prisma-client-js" 
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  USER
}

enum PaymentMethod {
  CASH
  CARD
  TRANSFER
  PAYPAL
  PAYPHONE
  OTHER
}

enum ReturnStatus {
  PENDING
  APPROVED
  REJECTED
}

enum EntityType {
  USER
  CUSTOMER
  PRODUCT
  ORDER
  INVOICE
  INVENTORY
  RETURN
  PAYMENT
  AUDIT_LOG
  SUBSCRIPTION
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  CANCELLED
}

model User {
  id        String   @id @default(uuid())
  name      String
  email     String   @unique
  password  String
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isActive  Boolean  @default(true)
  deletedAt DateTime?
  auditLogs AuditLog[]
}

model Customer {
  id         String   @id @default(uuid())
  name       String
  email      String   @unique
  phone      String?
  address    Address?
  orders     Order[]
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  isActive   Boolean  @default(true)
  deletedAt  DateTime?
}

model Address {
  id         String   @id @default(uuid())
  street     String
  city       String
  state      String
  country    String
  postalCode String
  customer   Customer @relation(fields: [customerId], references: [id])
  customerId String   @unique
}

model Product {
  id           String        @id @default(uuid())
  name         String
  description  String?
  price        Float
  sku          String        @unique
  stock        Int
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  isActive     Boolean       @default(true)
  deletedAt    DateTime?
  orderItems   OrderItem[]
  invoiceItems InvoiceItem[]
  inventoryLogs InventoryLog[]
}

model InventoryLog {
  id         String   @id @default(uuid())
  product    Product  @relation(fields: [productId], references: [id])
  productId  String
  quantity   Int
  reason     String
  createdAt  DateTime @default(now())
}

model Order {
  id         String     @id @default(uuid())
  customer   Customer   @relation(fields: [customerId], references: [id])
  customerId String
  date       DateTime   @default(now())
  total      Float
  status     String
  payment    Payment?
  invoice    Invoice?   // Relación inversa con Invoice
  orderItems OrderItem[]
  returns    Return[]
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  isActive   Boolean    @default(true)
  deletedAt  DateTime?
}

model OrderItem {
  id        String  @id @default(uuid())
  order     Order   @relation(fields: [orderId], references: [id])
  orderId   String
  product   Product @relation(fields: [productId], references: [id])
  productId String
  quantity  Int
  price     Float
}

model Invoice {
  id           String        @id @default(uuid())
  order        Order         @relation(fields: [orderId], references: [id])
  orderId      String        @unique  // Relación 1:1, se requiere que sea único
  total        Float
  issuedAt     DateTime      @default(now())
  invoiceItems InvoiceItem[]
}

model InvoiceItem {
  id         String  @id @default(uuid())
  invoice    Invoice @relation(fields: [invoiceId], references: [id])
  invoiceId  String
  product    Product @relation(fields: [productId], references: [id])
  productId  String
  quantity   Int
  price      Float
}

model Return {
  id        String       @id @default(uuid())
  order     Order        @relation(fields: [orderId], references: [id])
  orderId   String
  reason    String
  status    ReturnStatus
  createdAt DateTime     @default(now())
}

model Payment {
  id            String        @id @default(uuid())
  order         Order         @relation(fields: [orderId], references: [id])
  orderId       String        @unique  // Relación 1:1, se requiere unicidad
  method        PaymentMethod
  transactionId String?
  paidAt        DateTime      @default(now())
  amount        Float
  status        String?
}

model AuditLog {
  id         String     @id @default(uuid())
  user       User?      @relation(fields: [userId], references: [id])
  userId     String?
  action     String
  entity     EntityType
  entityId   String
  oldValue   Json?
  newValue   Json?
  timestamp  DateTime   @default(now())
}

model Subscription {
  id            String             @id @default(uuid())
  companyName   String
  email         String             @unique
  startDate     DateTime
  endDate       DateTime
  status        SubscriptionStatus
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  isActive      Boolean            @default(true)
  deletedAt     DateTime?
}
